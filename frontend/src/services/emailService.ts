import axios from 'axios';
import { Email, EmailsResponse, EmailFilter, EmailAnalytics, EmailDetail } from '../types/email';

// API base URL
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

// Axios instance with auth
const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor to add auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

/**
 * Get emails with pagination and filtering
 */
export const getEmails = async (filters: EmailFilter): Promise<EmailsResponse> => {
  try {
    const { data } = await apiClient.get('/emails', {
      params: {
        page: 1,
        per_page: 10,
        filter: filters.category,
        time_range: filters.timeRange,
        sort: filters.sort,
        sentiment: filters.sentiment,
        query: filters.query,
        label: filters.label,
        has_attachments: filters.hasAttachments,
        unread: filters.unread,
        starred: filters.starred,
      },
    });
    return data.data;
  } catch (error) {
    console.error('Error fetching emails:', error);
    throw error;
  }
};

/**
 * Get a single email by ID with detailed analysis
 */
export const getEmailById = async (id: string): Promise<EmailDetail> => {
  try {
    const { data } = await apiClient.get(`/emails/${id}`);
    return data.data;
  } catch (error) {
    console.error(`Error fetching email ${id}:`, error);
    throw error;
  }
};

/**
 * Get email analytics data
 */
export const getEmailAnalytics = async (timeRange: string): Promise<EmailAnalytics> => {
  try {
    const { data } = await apiClient.get('/emails/analytics', {
      params: { period: timeRange },
    });
    return data.data;
  } catch (error) {
    console.error('Error fetching email analytics:', error);
    throw error;
  }
};

/**
 * Get all email categories with counts
 */
export const getEmailCategories = async (): Promise<{ name: string; count: number }[]> => {
  try {
    const { data } = await apiClient.get('/emails/categories');
    return data.data;
  } catch (error) {
    console.error('Error fetching email categories:', error);
    throw error;
  }
};

/**
 * Search emails with a natural language query
 */
export const searchEmails = async (
  query: string,
  page = 1,
  perPage = 10
): Promise<EmailsResponse> => {
  try {
    const { data } = await apiClient.post('/emails/search', {
      query,
      page,
      per_page: perPage,
    });
    return data.data;
  } catch (error) {
    console.error('Error searching emails:', error);
    throw error;
  }
};

/**
 * Perform bulk action on multiple emails
 */
export const performBulkAction = async (
  emailIds: string[],
  action: 'archive' | 'delete' | 'mark_read' | 'mark_unread' | 'categorize',
  params?: Record<string, any>
): Promise<{ processed: number; failed: number }> => {
  try {
    const { data } = await apiClient.post('/emails/bulk-action', {
      email_ids: emailIds,
      action,
      params,
    });
    return data.data;
  } catch (error) {
    console.error('Error performing bulk action:', error);
    throw error;
  }
};

/**
 * Toggle star status of an email
 */
export const toggleStarEmail = async (id: string, starred: boolean): Promise<void> => {
  try {
    await apiClient.patch(`/emails/${id}`, {
      starred,
    });
  } catch (error) {
    console.error(`Error toggling star for email ${id}:`, error);
    throw error;
  }
};

/**
 * Mark email as read/unread
 */
export const markEmailReadStatus = async (id: string, read: boolean): Promise<void> => {
  try {
    await apiClient.patch(`/emails/${id}`, {
      unread: !read,
    });
  } catch (error) {
    console.error(`Error marking email ${id} as ${read ? 'read' : 'unread'}:`, error);
    throw error;
  }
};

// Mock data for development (remove in production)
export const getMockEmails = (): EmailsResponse => {
  const mockEmails: Email[] = Array.from({ length: 15 }, (_, i) => ({
    id: `email-${i + 1}`,
    subject: `Test Email Subject ${i + 1}`,
    sender: `sender${i + 1}@example.com`,
    sender_name: `Sender Name ${i + 1}`,
    sender_email: `sender${i + 1}@example.com`,
    recipient: 'recipient@example.com',
    date: new Date(Date.now() - i * 3600000).toISOString(),
    body: `This is the body of test email ${i + 1}. It contains some text that will be used for testing.`,
    summary: `This is a summary of email ${i + 1} generated by AI.`,
    sentiment: i % 3 === 0 ? 'positive' : i % 3 === 1 ? 'neutral' : 'negative',
    sentiment_score: Math.random(),
    categories: [
      ['Urgent', 'Action Required', 'Meeting'][i % 3],
      ['Project Update', 'Information', 'External'][Math.floor(i / 5)],
    ],
    importance_score: Math.random(),
    action_items: i % 2 === 0 ? [`Action item ${i + 1}`, `Another action ${i + 1}`] : [],
    topics: [`Topic ${i + 1}`, `Another topic ${i + 1}`],
    has_attachments: i % 3 === 0,
    starred: i % 5 === 0,
    unread: i % 4 === 0,
  }));

  return {
    emails: mockEmails,
    pagination: {
      total: 40,
      page: 1,
      per_page: 10,
      pages: 4,
    },
  };
};

export const getMockAnalytics = (): EmailAnalytics => {
  return {
    totalEmails: 245,
    emailTrend: 12.5,
    averageSentimentScore: 0.65,
    sentimentTrend: 5.2,
    dominantSentiment: 'positive',
    responseRate: 0.78,
    responseRateTrend: -2.1,
    highPriorityCount: 18,
    priorityTrend: 33.3,
    topSenders: [
      { name: 'John Smith', count: 28 },
      { name: 'Alice Johnson', count: 22 },
      { name: 'Robert Brown', count: 17 },
      { name: 'Emily Davis', count: 15 },
      { name: 'Michael Wilson', count: 12 },
    ],
    topCategories: [
      { name: 'Information', count: 86 },
      { name: 'Action Required', count: 52 },
      { name: 'Project Update', count: 41 },
      { name: 'Meeting', count: 33 },
      { name: 'External Client', count: 23 },
    ],
    categoriesDistribution: [
      { name: 'Information', value: 86 },
      { name: 'Action Required', value: 52 },
      { name: 'Project Update', value: 41 },
      { name: 'Meeting', value: 33 },
      { name: 'External Client', value: 23 },
      { name: 'Other', value: 10 },
    ],
    volumeByDay: Array.from({ length: 7 }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - (6 - i));
      const positive = Math.floor(Math.random() * 15) + 5;
      const neutral = Math.floor(Math.random() * 10) + 5;
      const negative = Math.floor(Math.random() * 5) + 1;
      return {
        date: date.toISOString().split('T')[0],
        positive,
        neutral,
        negative,
        total: positive + neutral + negative,
      };
    }),
    responseTimeAverage: 3.2, // hours
    actionItemsCount: 87,
    attachmentsCount: 34,
  };
}; 